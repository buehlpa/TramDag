window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "tramdag", "modulename": "tramdag", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig", "modulename": "tramdag", "qualname": "TramDagConfig", "kind": "class", "doc": "<p>Configuration manager for TRAM-DAG experiments.</p>\n\n<p>This class encapsulates:</p>\n\n<ul>\n<li>The experiment configuration dictionary (<code>conf_dict</code>).</li>\n<li>Its backing file path (<code>CONF_DICT_PATH</code>).</li>\n<li>Utilities to load, validate, modify, and persist configuration.</li>\n<li>DAG visualization and interactive editing helpers.</li>\n</ul>\n\n<h2 id=\"typical-usage\">Typical usage</h2>\n\n<ul>\n<li>Load existing configuration from disk via <code>TramDagConfig.load_json</code>.</li>\n<li>Or create/reuse experiment setup via <code>TramDagConfig().setup_configuration</code>.</li>\n<li>Update sections such as <code>data_type</code>, adjacency matrix, and neural network\nmodel names using the provided methods.</li>\n</ul>\n"}, {"fullname": "tramdag.TramDagConfig.__init__", "modulename": "tramdag", "qualname": "TramDagConfig.__init__", "kind": "function", "doc": "<p>Initialize a TramDagConfig instance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>conf_dict : dict or None, optional\n    Configuration dictionary. If None, an empty dict is used and can\n    be populated later. Default is None.\nCONF_DICT_PATH : str or None, optional\n    Path to the configuration file on disk. Default is None.\n_verify : bool, optional\n    If True, run <code>_verify_completeness()</code> after initialization.\n    Default is False.\n**kwargs\n    Additional attributes to be set on the instance. Keys \"conf_dict\"\n    and \"CONF_DICT_PATH\" are forbidden and raise a ValueError.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If any key in <code>kwargs</code> is \"conf_dict\" or \"CONF_DICT_PATH\".</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>By default, <code>debug</code> and <code>verbose</code> are set to False. They can be\noverridden via <code>kwargs</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">conf_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">_verify</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "tramdag.TramDagConfig.debug", "modulename": "tramdag", "qualname": "TramDagConfig.debug", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.verbose", "modulename": "tramdag", "qualname": "TramDagConfig.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.conf_dict", "modulename": "tramdag", "qualname": "TramDagConfig.conf_dict", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.CONF_DICT_PATH", "modulename": "tramdag", "qualname": "TramDagConfig.CONF_DICT_PATH", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.load_json", "modulename": "tramdag", "qualname": "TramDagConfig.load_json", "kind": "function", "doc": "<p>Load a configuration from a JSON file and construct a TramDagConfig.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str\n    Path to the configuration JSON file.\ndebug : bool, optional\n    If True, initialize the instance with <code>debug=True</code>. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagConfig\n    Newly created configuration instance with <code>conf_dict</code> loaded from\n    <code>CONF_DICT_PATH</code> and <code>_verify_completeness()</code> executed.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>FileNotFoundError\n    If the configuration file cannot be found (propagated by\n    <code>load_configuration_dict</code>).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">debug</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.update", "modulename": "tramdag", "qualname": "TramDagConfig.update", "kind": "function", "doc": "<p>Reload the latest configuration from disk into this instance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>None</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is not set on the instance.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The current in-memory <code>conf_dict</code> is overwritten by the contents\nloaded from <code>CONF_DICT_PATH</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.save", "modulename": "tramdag", "qualname": "TramDagConfig.save", "kind": "function", "doc": "<p>Persist the current configuration dictionary to disk.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str or None, optional\n    Target path for the configuration file. If None, uses\n    <code>self.CONF_DICT_PATH</code>. Default is None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If neither the function argument nor <code>self.CONF_DICT_PATH</code>\n    provides a valid path.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The resulting file is written via <code>write_configuration_dict</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.compute_levels", "modulename": "tramdag", "qualname": "TramDagConfig.compute_levels", "kind": "function", "doc": "<p>Infer and update ordinal/categorical levels from data.</p>\n\n<p>For each variable in the configuration's <code>data_type</code> section, this\nmethod uses the provided DataFrame to construct a levels dictionary\nand injects the corresponding \"levels\" entry into <code>conf_dict[\"nodes\"]</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    DataFrame used to infer levels for configured variables.\nwrite : bool, optional\n    If True and <code>CONF_DICT_PATH</code> is set, the updated configuration is\n    written back to disk. Default is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>Exception\n    If saving the configuration fails when <code>write=True</code>.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Variables present in <code>levels_dict</code> but not in <code>conf_dict[\"nodes\"]</code>\ntrigger a warning and are skipped.</li>\n<li>If <code>self.verbose</code> or <code>self.debug</code> is True, a success message is printed\nwhen the configuration is saved.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">write</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.plot_dag", "modulename": "tramdag", "qualname": "TramDagConfig.plot_dag", "kind": "function", "doc": "<p>Visualize the DAG defined by the configuration.</p>\n\n<p>Nodes are categorized and colored as:</p>\n\n<ul>\n<li>Source nodes (no incoming edges): green.</li>\n<li>Sink nodes (no outgoing edges): red.</li>\n<li>Intermediate nodes: light blue.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>seed : int, optional\n    Random seed for layout stability in the spring layout fallback.\n    Default is 42.\ncausal_order : bool, optional\n    If True, attempt to use Graphviz 'dot' layout via\n    <code>networkx.nx_agraph.graphviz_layout</code> to preserve causal ordering.\n    If False or if Graphviz is unavailable, use <code>spring_layout</code>.\n    Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>adj_matrix</code> or <code>data_type</code> is missing or inconsistent with each other,\n    or if the adjacency matrix fails validation.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Edge labels are colored by prefix:</p>\n\n<ul>\n<li>\"ci\": blue</li>\n<li>\"ls\": red</li>\n<li>\"cs\": green</li>\n<li>other: black</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">42</span>, </span><span class=\"param\"><span class=\"n\">causal_order</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.setup_configuration", "modulename": "tramdag", "qualname": "TramDagConfig.setup_configuration", "kind": "function", "doc": "<p>Create or reuse a configuration for an experiment.</p>\n\n<p>This method behaves differently depending on how it is called:</p>\n\n<ol>\n<li>Class call (e.g. <code>TramDagConfig.setup_configuration(...)</code>):</li>\n</ol>\n\n<ul>\n<li>Creates or loads a configuration at the resolved path.</li>\n<li>Returns a new <code>TramDagConfig</code> instance.</li>\n</ul>\n\n<ol start=\"2\">\n<li>Instance call (e.g. <code>cfg.setup_configuration(...)</code>):</li>\n</ol>\n\n<ul>\n<li>Updates <code>self.conf_dict</code> and <code>self.CONF_DICT_PATH</code> in place.</li>\n<li>Optionally verifies completeness.</li>\n<li>Returns None.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>experiment_name : str or None, optional\n    Name of the experiment. If None, defaults to \"experiment_1\".\nEXPERIMENT_DIR : str or None, optional\n    Directory for the experiment. If None, defaults to\n    <code>&lt;cwd&gt;/&lt;experiment_name&gt;</code>.\ndebug : bool, optional\n    If True, initialize / update with <code>debug=True</code>. Default is False.\n_verify : bool, optional\n    If True, call <code>_verify_completeness()</code> after loading. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagConfig or None\n    - A new instance when called on the class.\n    - None when called on an existing instance.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>A configuration file named \"configuration.json\" is created if it does\nnot exist yet.</li>\n<li>Underlying creation uses <code>create_and_write_new_configuration_dict</code>\nand <code>load_configuration_dict</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">experiment_name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">EXPERIMENT_DIR</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">_verify</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.set_data_type", "modulename": "tramdag", "qualname": "TramDagConfig.set_data_type", "kind": "function", "doc": "<p>Update or write the <code>data_type</code> section of a configuration file.</p>\n\n<p>Supports both class-level and instance-level usage:</p>\n\n<ul>\n<li>Class call:</li>\n<li>Requires <code>CONF_DICT_PATH</code> argument.</li>\n<li>Reads the file if it exists, or starts from an empty dict.</li>\n<li><p>Writes updated configuration to <code>CONF_DICT_PATH</code>.</p></li>\n<li><p>Instance call:</p></li>\n<li>Uses <code>self.CONF_DICT_PATH</code> if available, otherwise defaults to\n<code>&lt;cwd&gt;/configuration.json</code> if no path is provided.</li>\n<li>Updates <code>self.conf_dict</code> and <code>self.CONF_DICT_PATH</code> after writing.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data_type : dict\n    Mapping <code>{variable_name: type_spec}</code>, where <code>type_spec</code> encodes\n    modeling types (e.g. continuous, ordinal, etc.).\nCONF_DICT_PATH : str or None, optional\n    Path to the configuration file. Must be provided for class calls.\n    For instance calls, defaults as described above.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is missing when called on the class, or if\n    validation of data types fails.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Variable names are validated via <code>validate_variable_names</code>.</li>\n<li>Data type values are validated via <code>validate_data_types</code>.</li>\n<li>A textual summary of modeling settings is printed via\n<code>print_data_type_modeling_setting</code>, if possible.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.set_meta_adj_matrix", "modulename": "tramdag", "qualname": "TramDagConfig.set_meta_adj_matrix", "kind": "function", "doc": "<p>Launch the interactive editor to set or modify the adjacency matrix.</p>\n\n<p>This method:</p>\n\n<ol>\n<li>Resolves the configuration path either from the argument or, for\ninstances, from <code>self.CONF_DICT_PATH</code>.</li>\n<li>Invokes <code>interactive_adj_matrix</code> to edit the adjacency matrix.</li>\n<li>For instances, reloads the updated configuration into <code>self.conf_dict</code>.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str or None, optional\n    Path to the configuration file. Must be provided when called\n    on the class. For instance calls, defaults to <code>self.CONF_DICT_PATH</code>.\nseed : int, optional\n    Random seed for any layout or stochastic behavior in the interactive\n    editor. Default is 5.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is not provided and cannot be inferred\n    (e.g. in a class call without path).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><code>self.update()</code> is called at the start to ensure the in-memory config\nis in sync with the file before launching the editor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.set_tramdag_nn_models", "modulename": "tramdag", "qualname": "TramDagConfig.set_tramdag_nn_models", "kind": "function", "doc": "<p>Launch the interactive editor to set TRAM-DAG neural network model names.</p>\n\n<p>Depending on call context:</p>\n\n<ul>\n<li>Class call:</li>\n<li>Requires <code>CONF_DICT_PATH</code> argument.</li>\n<li><p>Returns nothing and does not modify a specific instance.</p></li>\n<li><p>Instance call:</p></li>\n<li>Resolves <code>CONF_DICT_PATH</code> from the argument or <code>self.CONF_DICT_PATH</code>.</li>\n<li>Updates <code>self.conf_dict</code> and <code>self.CONF_DICT_PATH</code> if the editor\nreturns an updated configuration.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str or None, optional\n    Path to the configuration file. Must be provided when called on\n    the class. For instance calls, defaults to <code>self.CONF_DICT_PATH</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is not provided and cannot be inferred\n    (e.g. in a class call without path).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The interactive editor is invoked via <code>interactive_nn_names_matrix</code>.\nIf it returns <code>None</code>, the instance configuration is left unchanged.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagDataset", "modulename": "tramdag", "qualname": "TramDagDataset", "kind": "class", "doc": "<h1 id=\"tramdagdataset\">TramDagDataset</h1>\n\n<p>The <code>TramDagDataset</code> class handles structured data preparation for TRAM-DAG\nmodels. It wraps a pandas DataFrame together with its configuration and provides\nutilities for scaling, transformation, and efficient DataLoader construction\nfor each node in a DAG-based configuration.</p>\n\n<hr />\n\n<h2 id=\"core-responsibilities\">Core Responsibilities</h2>\n\n<ul>\n<li>Validate and store configuration metadata (<code>TramDagConfig</code>).</li>\n<li>Manage per-node settings for DataLoader creation (batch size, shuffling, workers).</li>\n<li>Compute scaling information (quantile-based min/max).</li>\n<li>Optionally precompute and cache dataset representations.</li>\n<li>Expose PyTorch Dataset and DataLoader interfaces for model training.</li>\n</ul>\n\n<hr />\n\n<h2 id=\"key-attributes\">Key Attributes</h2>\n\n<ul>\n<li><p><strong>df</strong> : pandas.DataFrame<br />\nThe dataset content used for building loaders and computing scaling.</p></li>\n<li><p><strong>cfg</strong> : TramDagConfig<br />\nConfiguration object defining nodes and variable metadata.</p></li>\n<li><p><strong>nodes_dict</strong> : dict<br />\nMapping of variable names to node specifications from the configuration.</p></li>\n<li><p><strong>loaders</strong> : dict<br />\nMapping of node names to <code>torch.utils.data.DataLoader</code> instances or <code>GenericDataset</code> objects.</p></li>\n<li><p><strong>DEFAULTS</strong> : dict<br />\nDefault DataLoader and dataset-related settings (e.g., batch_size, shuffle, num_workers, etc.).</p></li>\n</ul>\n\n<hr />\n\n<h2 id=\"main-methods\">Main Methods</h2>\n\n<ul>\n<li><p><strong>from_dataframe(df, cfg, **kwargs)</strong><br />\nConstruct the dataset directly from a pandas DataFrame.</p></li>\n<li><p><strong>compute_scaling(df=None, write=True)</strong><br />\nCompute per-variable min/max scaling values from data.</p></li>\n<li><p><strong>summary()</strong><br />\nPrint dataset overview including shape, dtypes, statistics, and node settings.</p></li>\n</ul>\n\n<hr />\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Intended for training data; <code>compute_scaling()</code> should use only training subsets.</li>\n<li>Compatible with both CPU and GPU DataLoader options.</li>\n<li>Strict validation of keyword arguments against <code>DEFAULTS</code> prevents silent misconfiguration.</li>\n</ul>\n\n<hr />\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cfg</span> <span class=\"o\">=</span> <span class=\"n\">TramDagConfig</span><span class=\"o\">.</span><span class=\"n\">from_json</span><span class=\"p\">(</span><span class=\"s2\">&quot;config.json&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dataset</span> <span class=\"o\">=</span> <span class=\"n\">TramDagDataset</span><span class=\"o\">.</span><span class=\"n\">from_dataframe</span><span class=\"p\">(</span><span class=\"n\">train_df</span><span class=\"p\">,</span> <span class=\"n\">cfg</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">1024</span><span class=\"p\">,</span> <span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dataset</span><span class=\"o\">.</span><span class=\"n\">summary</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">minmax</span> <span class=\"o\">=</span> <span class=\"n\">dataset</span><span class=\"o\">.</span><span class=\"n\">compute_scaling</span><span class=\"p\">(</span><span class=\"n\">train_df</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">loader</span> <span class=\"o\">=</span> <span class=\"n\">dataset</span><span class=\"o\">.</span><span class=\"n\">loaders</span><span class=\"p\">[</span><span class=\"s2\">&quot;variable_x&quot;</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">loader</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n", "bases": "typing.Generic[+_T_co]"}, {"fullname": "tramdag.TramDagDataset.__init__", "modulename": "tramdag", "qualname": "TramDagDataset.__init__", "kind": "function", "doc": "<p>Initialize an empty TramDagDataset shell.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This constructor does not attach data or configuration. Use\n<code>TramDagDataset.from_dataframe</code> to obtain a ready-to-use instance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "tramdag.TramDagDataset.DEFAULTS", "modulename": "tramdag", "qualname": "TramDagDataset.DEFAULTS", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;batch_size&#x27;: 32000, &#x27;shuffle&#x27;: True, &#x27;num_workers&#x27;: 4, &#x27;pin_memory&#x27;: True, &#x27;return_intercept_shift&#x27;: True, &#x27;debug&#x27;: False, &#x27;transform&#x27;: None, &#x27;use_dataloader&#x27;: True, &#x27;use_precomputed&#x27;: False, &#x27;sampler&#x27;: None, &#x27;batch_sampler&#x27;: None, &#x27;collate_fn&#x27;: None, &#x27;drop_last&#x27;: False, &#x27;timeout&#x27;: 0, &#x27;worker_init_fn&#x27;: None, &#x27;multiprocessing_context&#x27;: None, &#x27;generator&#x27;: None, &#x27;prefetch_factor&#x27;: 2, &#x27;persistent_workers&#x27;: True, &#x27;pin_memory_device&#x27;: &#x27;&#x27;}"}, {"fullname": "tramdag.TramDagDataset.from_dataframe", "modulename": "tramdag", "qualname": "TramDagDataset.from_dataframe", "kind": "function", "doc": "<p>Create a TramDagDataset instance directly from a pandas DataFrame.</p>\n\n<p>This classmethod:</p>\n\n<ol>\n<li>Validates keyword arguments against <code>DEFAULTS</code>.</li>\n<li>Merges user overrides with defaults into a resolved settings dict.</li>\n<li>Stores the configuration and verifies its completeness.</li>\n<li>Applies settings to the instance.</li>\n<li>Builds per-node datasets and DataLoaders.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input DataFrame containing the dataset.\ncfg : TramDagConfig\n    Configuration object defining nodes and variable metadata.\n**kwargs\n    Optional overrides for <code>DEFAULTS</code>. All keys must exist in\n    <code>TramDagDataset.DEFAULTS</code>. Common keys include:</p>\n\n<pre><code>batch_size : int\n    Batch size for DataLoaders.\nshuffle : bool\n    Whether to shuffle samples per epoch.\nnum_workers : int\n    Number of DataLoader workers.\npin_memory : bool\n    Whether to pin memory for faster host-to-device transfers.\nreturn_intercept_shift : bool\n    Whether datasets should return intercept/shift information.\ndebug : bool\n    Enable debug printing.\ntransform : callable or dict or None\n    Optional transform(s) applied to samples.\nuse_dataloader : bool\n    If True, construct DataLoaders; else store raw Dataset objects.\nuse_precomputed : bool\n    If True, precompute dataset representation to disk and reload it.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagDataset\n    Initialized dataset instance.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If <code>df</code> is not a pandas DataFrame.\nValueError\n    If unknown keyword arguments are provided (when validation is enabled).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If <code>shuffle=True</code> and the inferred variable name of <code>df</code> suggests\nvalidation/test data (e.g. \"val\", \"test\"), a warning is printed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">cfg</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagDataset.compute_scaling", "modulename": "tramdag", "qualname": "TramDagDataset.compute_scaling", "kind": "function", "doc": "<p>Compute variable-wise scaling parameters from data.</p>\n\n<p>Per variable, this method computes approximate minimum and maximum\nvalues using the 5th and 95th percentiles. This is typically used\nto derive robust normalization/clipping ranges from training data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame or None, optional\n    DataFrame used to compute scaling. If None, <code>self.df</code> is used.\nwrite : bool, optional\n    Unused placeholder for interface compatibility with other components.\n    Kept for potential future extensions. Default is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Mapping <code>{column_name: [min_value, max_value]}</code>, where values\n    are derived from the 0.05 and 0.95 quantiles.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If <code>self.debug</code> is True, the method emits debug messages about the\ndata source. Only training data should be used to avoid leakage.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">write</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagDataset.summary", "modulename": "tramdag", "qualname": "TramDagDataset.summary", "kind": "function", "doc": "<p>Print a structured overview of the dataset and configuration.</p>\n\n<p>The summary includes:</p>\n\n<ol>\n<li>DataFrame information:</li>\n</ol>\n\n<ul>\n<li>Shape</li>\n<li>Columns</li>\n<li>Head (first rows)</li>\n<li>Dtypes</li>\n<li>Descriptive statistics</li>\n</ul>\n\n<ol start=\"2\">\n<li>Configuration overview:</li>\n</ol>\n\n<ul>\n<li>Number of nodes</li>\n<li>Loader mode (DataLoader vs. raw Dataset)</li>\n<li>Precomputation status</li>\n</ul>\n\n<ol start=\"3\">\n<li>Node settings:</li>\n</ol>\n\n<ul>\n<li>Batch size</li>\n<li>Shuffle flag</li>\n<li>num_workers</li>\n<li>pin_memory</li>\n<li>return_intercept_shift</li>\n<li>debug</li>\n<li>transform</li>\n</ul>\n\n<ol start=\"4\">\n<li>DataLoader overview:</li>\n</ol>\n\n<ul>\n<li>Type and length of each loader.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>None</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Intended for quick inspection and debugging. Uses <code>print</code> statements\nand does not return structured metadata.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel", "modulename": "tramdag", "qualname": "TramDagModel", "kind": "class", "doc": "<p>Probabilistic DAG model built from node-wise TRAMs (transformation models).</p>\n\n<p>This class manages:</p>\n\n<ul>\n<li>Configuration and per-node model construction.</li>\n<li>Data scaling (min\u2013max).</li>\n<li>Training (sequential or per-node parallel on CPU).</li>\n<li>Diagnostics (loss history, intercepts, linear shifts, latents).</li>\n<li>Sampling from the joint DAG and loading stored samples.</li>\n<li>High-level summaries and plotting utilities.</li>\n</ul>\n"}, {"fullname": "tramdag.TramDagModel.__init__", "modulename": "tramdag", "qualname": "TramDagModel.__init__", "kind": "function", "doc": "<p>Initialize an empty TramDagModel shell.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This constructor does not build any node models and does not attach a\nconfiguration. Use <code>TramDagModel.from_config</code> or <code>TramDagModel.from_directory</code>\nto obtain a fully configured and ready-to-use instance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "tramdag.TramDagModel.DEFAULTS_CONFIG", "modulename": "tramdag", "qualname": "TramDagModel.DEFAULTS_CONFIG", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;set_initial_weights&#x27;: False, &#x27;debug&#x27;: False, &#x27;verbose&#x27;: False, &#x27;device&#x27;: &#x27;auto&#x27;, &#x27;initial_data&#x27;: None, &#x27;overwrite_initial_weights&#x27;: True}"}, {"fullname": "tramdag.TramDagModel.DEFAULTS_FIT", "modulename": "tramdag", "qualname": "TramDagModel.DEFAULTS_FIT", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;epochs&#x27;: 100, &#x27;train_list&#x27;: None, &#x27;callbacks&#x27;: None, &#x27;learning_rate&#x27;: 0.01, &#x27;device&#x27;: &#x27;auto&#x27;, &#x27;optimizers&#x27;: None, &#x27;schedulers&#x27;: None, &#x27;use_scheduler&#x27;: False, &#x27;save_linear_shifts&#x27;: True, &#x27;save_simple_intercepts&#x27;: True, &#x27;debug&#x27;: False, &#x27;verbose&#x27;: True, &#x27;train_mode&#x27;: &#x27;sequential&#x27;, &#x27;return_history&#x27;: False, &#x27;overwrite_inital_weights&#x27;: True, &#x27;num_workers&#x27;: 4, &#x27;persistent_workers&#x27;: True, &#x27;prefetch_factor&#x27;: 4, &#x27;batch_size&#x27;: 1000}"}, {"fullname": "tramdag.TramDagModel.debug", "modulename": "tramdag", "qualname": "TramDagModel.debug", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagModel.verbose", "modulename": "tramdag", "qualname": "TramDagModel.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagModel.device", "modulename": "tramdag", "qualname": "TramDagModel.device", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagModel.get_device", "modulename": "tramdag", "qualname": "TramDagModel.get_device", "kind": "function", "doc": "<p>Resolve the target device string from a settings dictionary.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>settings : dict\n    Dictionary containing at least a key <code>\"device\"</code> with one of\n    {\"auto\", \"cpu\", \"cuda\"}. If missing, \"auto\" is assumed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Device string, either \"cpu\" or \"cuda\".</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If <code>device == \"auto\"</code>, CUDA is selected if available, otherwise CPU.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">settings</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.from_config", "modulename": "tramdag", "qualname": "TramDagModel.from_config", "kind": "function", "doc": "<p>Construct a TramDagModel from a TramDagConfig object.</p>\n\n<p>This builds one TRAM model per node in the DAG and optionally writes\nthe initial model parameters to disk.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cfg : TramDagConfig\n    Configuration wrapper holding the underlying configuration dictionary,\n    including at least:\n    - <code>conf_dict[\"nodes\"]</code>: mapping of node names to node configs.\n    - <code>conf_dict[\"PATHS\"][\"EXPERIMENT_DIR\"]</code>: experiment directory.\n**kwargs\n    Node-level construction options. Each key must be present in\n    <code>DEFAULTS_CONFIG</code>. Values can be:\n    - scalar: applied to all nodes.\n    - dict: mapping <code>{node_name: value}</code> for per-node overrides.</p>\n\n<pre><code>Common keys include:\ndevice : {\"auto\", \"cpu\", \"cuda\"}, default \"auto\"\n    Device selection (CUDA if available when \"auto\").\ndebug : bool, default False\n    If True, print debug messages.\nverbose : bool, default False\n    If True, print informational messages.\nset_initial_weights : bool\n    Passed to underlying TRAM model constructors.\noverwrite_initial_weights : bool, default True\n    If True, overwrite any existing ``initial_model.pt`` files per node.\ninitial_data : Any\n    Optional object passed down to node constructors.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagModel\n    Fully initialized instance with:\n    - <code>cfg</code>\n    - <code>nodes_dict</code>\n    - <code>models</code> (per-node TRAMs)\n    - <code>settings</code> (resolved per-node config)</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If any dict-valued kwarg does not provide values for exactly the set\n    of nodes in <code>cfg.conf_dict[\"nodes\"]</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">cfg</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.from_directory", "modulename": "tramdag", "qualname": "TramDagModel.from_directory", "kind": "function", "doc": "<p>Reconstruct a TramDagModel from an experiment directory on disk.</p>\n\n<p>This method:</p>\n\n<ol>\n<li>Loads the configuration JSON.</li>\n<li>Wraps it in a TramDagConfig.</li>\n<li>Builds all node models via <code>from_config</code>.</li>\n<li>Loads the min\u2013max scaling dictionary.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>EXPERIMENT_DIR : str\n    Path to an experiment directory containing:\n    - <code>configuration.json</code>\n    - <code>min_max_scaling.json</code>.\ndevice : {\"auto\", \"cpu\", \"cuda\"}, optional\n    Device selection. Default is \"auto\".\ndebug : bool, optional\n    If True, enable debug messages. Default is False.\nverbose : bool, optional\n    If True, enable informational messages. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagModel\n    A TramDagModel instance with models, config, and scaling loaded.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>FileNotFoundError\n    If configuration or min\u2013max files cannot be found.\nRuntimeError\n    If the min\u2013max file cannot be read or parsed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">EXPERIMENT_DIR</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.load_or_compute_minmax", "modulename": "tramdag", "qualname": "TramDagModel.load_or_compute_minmax", "kind": "function", "doc": "<p>Load an existing Min\u2013Max scaling dictionary from disk or compute a new one \nfrom the provided training dataset.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>use_existing : bool, optional (default=False)\n    If True, attempts to load an existing <code>min_max_scaling.json</code> file \n    from the experiment directory. Raises an error if the file is missing \n    or unreadable.</p>\n\n<p>write : bool, optional (default=True)\n    If True, writes the computed Min\u2013Max scaling dictionary to \n    <code>&lt;EXPERIMENT_DIR&gt;/min_max_scaling.json</code>.</p>\n\n<p>td_train_data : object, optional\n    Training dataset used to compute scaling statistics. If not provided,\n    the method will ensure or construct it via <code>_ensure_dataset(data=..., is_val=False)</code>.</p>\n\n<h2 id=\"behavior\">Behavior</h2>\n\n<ul>\n<li>If <code>use_existing=True</code>, loads the JSON file containing previously saved \nmin\u2013max values and stores it in <code>self.minmax_dict</code>.</li>\n<li>If <code>use_existing=False</code>, computes a new scaling dictionary using \n<code>td_train_data.compute_scaling()</code> and stores the result in \n<code>self.minmax_dict</code>.</li>\n<li>Optionally writes the computed dictionary to disk.</li>\n</ul>\n\n<h2 id=\"side-effects\">Side Effects</h2>\n\n<ul>\n<li>Populates <code>self.minmax_dict</code> with scaling values.</li>\n<li>Writes or loads the file <code>min_max_scaling.json</code> under \n<code>&lt;EXPERIMENT_DIR&gt;</code>.</li>\n<li>Prints diagnostic output if <code>self.debug</code> or <code>self.verbose</code> is True.</li>\n</ul>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>FileNotFoundError\n    If <code>use_existing=True</code> but the min\u2013max file does not exist.</p>\n\n<p>RuntimeError\n    If an existing min\u2013max file cannot be read or parsed.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The computed min\u2013max dictionary is expected to contain scaling statistics \nper feature, typically in the form:\n    {\n        \"node\": {\"min\": float, \"max\": float},\n        ...\n    }</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">td_train_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">use_existing</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">write</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.fit", "modulename": "tramdag", "qualname": "TramDagModel.fit", "kind": "function", "doc": "<p>Train TRAM models for all nodes in the DAG.</p>\n\n<p>Coordinates dataset preparation, min\u2013max scaling, and per-node training,\noptionally in parallel on CPU.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>train_data : pandas.DataFrame or TramDagDataset\n    Training data. If a DataFrame is given, it is converted into a\n    TramDagDataset using <code>_ensure_dataset</code>.\nval_data : pandas.DataFrame or TramDagDataset or None, optional\n    Validation data. If a DataFrame is given, it is converted into a\n    TramDagDataset. If None, no validation loss is computed.\n**kwargs\n    Overrides for <code>DEFAULTS_FIT</code>. All keys must exist in\n    <code>DEFAULTS_FIT</code>. Common options:</p>\n\n<pre><code>epochs : int, default 100\n    Number of training epochs per node.\nlearning_rate : float, default 0.01\n    Learning rate for the default Adam optimizer.\ntrain_list : list of str or None, optional\n    List of node names to train. If None, all nodes are trained.\ntrain_mode : {\"sequential\", \"parallel\"}, default \"sequential\"\n    Training mode. \"parallel\" uses joblib-based CPU multiprocessing.\n    GPU forces sequential mode.\ndevice : {\"auto\", \"cpu\", \"cuda\"}, default \"auto\"\n    Device selection.\noptimizers : dict or None\n    Optional mapping ``{node_name: optimizer}``. If provided for a\n    node, that optimizer is used instead of creating a new Adam.\nschedulers : dict or None\n    Optional mapping ``{node_name: scheduler}``.\nuse_scheduler : bool\n    If True, enable scheduler usage in the training loop.\nnum_workers : int\n    DataLoader workers in sequential mode (ignored in parallel).\npersistent_workers : bool\n    DataLoader persistence in sequential mode (ignored in parallel).\nprefetch_factor : int\n    DataLoader prefetch factor (ignored in parallel).\nbatch_size : int\n    Batch size for all node DataLoaders.\ndebug : bool\n    Enable debug output.\nverbose : bool\n    Enable informational logging.\nreturn_history : bool\n    If True, return a history dict.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict or None\n    If <code>return_history=True</code>, a dictionary mapping each node name\n    to its training history. Otherwise, returns None.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>train_mode</code> is not \"sequential\" or \"parallel\".</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">train_data</span>, </span><span class=\"param\"><span class=\"n\">val_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.loss_history", "modulename": "tramdag", "qualname": "TramDagModel.loss_history", "kind": "function", "doc": "<p>Load training and validation loss history for all nodes.</p>\n\n<p>Looks for per-node JSON files:</p>\n\n<ul>\n<li><code>EXPERIMENT_DIR/{node}/train_loss_hist.json</code></li>\n<li><code>EXPERIMENT_DIR/{node}/val_loss_hist.json</code></li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A dictionary mapping node names to:</p>\n\n<pre><code>```python\n</code></pre>\n\n<p>{\n    \"train\": list or None,\n    \"validation\": list or None\n}\n```</p>\n\n<pre><code>where each list contains NLL values per epoch, or None if not found.\n</code></pre>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved from the configuration.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.linear_shift_history", "modulename": "tramdag", "qualname": "TramDagModel.linear_shift_history", "kind": "function", "doc": "<p>Load linear shift term histories for all nodes.</p>\n\n<p>Each node history is expected in a JSON file named\n<code>linear_shifts_all_epochs.json</code> under the node directory.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A mapping <code>{node_name: pandas.DataFrame}</code>, where each DataFrame\n    contains linear shift weights across epochs.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved from the configuration.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If a history file is missing for a node, a warning is printed and the\nnode is omitted from the returned dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.simple_intercept_history", "modulename": "tramdag", "qualname": "TramDagModel.simple_intercept_history", "kind": "function", "doc": "<p>Load simple intercept histories for all nodes.</p>\n\n<p>Each node history is expected in a JSON file named\n<code>simple_intercepts_all_epochs.json</code> under the node directory.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A mapping <code>{node_name: pandas.DataFrame}</code>, where each DataFrame\n    contains intercept weights across epochs.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved from the configuration.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If a history file is missing for a node, a warning is printed and the\nnode is omitted from the returned dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.get_latent", "modulename": "tramdag", "qualname": "TramDagModel.get_latent", "kind": "function", "doc": "<p>Compute latent representations for all nodes in the DAG.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input data frame with columns corresponding to nodes in the DAG.\nverbose : bool, optional\n    If True, print informational messages during latent computation.\n    Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas.DataFrame\n    DataFrame containing the original columns plus latent variables\n    for each node (e.g. columns named <code>f\"{node}_U\"</code>).</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory is missing from the configuration or\n    if <code>self.minmax_dict</code> has not been set.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.plot_loss_history", "modulename": "tramdag", "qualname": "TramDagModel.plot_loss_history", "kind": "function", "doc": "<p>Plot training and validation loss evolution per node.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>variable : str or None, optional\n    If provided, plot loss history for this node only. If None, plot\n    histories for all nodes that have both train and validation logs.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Two subplots are produced:</p>\n\n<ul>\n<li>Full epoch history.</li>\n<li>Last 10% of epochs (or only the last epoch if fewer than 5 epochs).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.plot_linear_shift_history", "modulename": "tramdag", "qualname": "TramDagModel.plot_linear_shift_history", "kind": "function", "doc": "<p>Plot the evolution of linear shift terms over epochs.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data_dict : dict or None, optional\n    Pre-loaded mapping <code>{node_name: pandas.DataFrame}</code> containing shift\n    weights across epochs. If None, <code>linear_shift_history()</code> is called.\nnode : str or None, optional\n    If provided, plot only this node. Otherwise, plot all nodes\n    present in <code>data_dict</code>.\nref_lines : dict or None, optional\n    Optional mapping <code>{node_name: list of float}</code>. For each specified\n    node, horizontal reference lines are drawn at the given values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The function flattens nested list-like entries in the DataFrames to scalars,\nconverts epoch labels to numeric, and then draws one line per shift term.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_dict</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ref_lines</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.plot_simple_intercepts_history", "modulename": "tramdag", "qualname": "TramDagModel.plot_simple_intercepts_history", "kind": "function", "doc": "<p>Plot the evolution of simple intercept weights over epochs.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data_dict : dict or None, optional\n    Pre-loaded mapping <code>{node_name: pandas.DataFrame}</code> containing intercept\n    weights across epochs. If None, <code>simple_intercept_history()</code> is called.\nnode : str or None, optional\n    If provided, plot only this node. Otherwise, plot all nodes present\n    in <code>data_dict</code>.\nref_lines : dict or None, optional\n    Optional mapping <code>{node_name: list of float}</code>. For each specified\n    node, horizontal reference lines are drawn at the given values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Nested list-like entries in the DataFrames are reduced to scalars before\nplotting. One line is drawn per intercept parameter.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_dict</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ref_lines</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.plot_latents", "modulename": "tramdag", "qualname": "TramDagModel.plot_latents", "kind": "function", "doc": "<p>Visualize latent U distributions for one or all nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input data frame with raw node values.\nvariable : str or None, optional\n    If provided, only this node's latents are plotted. If None, all\n    nodes with latent columns are processed.\nconfidence : float, optional\n    Confidence level for QQ-plot bands (0 &lt; confidence &lt; 1).\n    Default is 0.95.\nsimulations : int, optional\n    Number of Monte Carlo simulations for QQ-plot bands. Default is 1000.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>For each node, two plots are produced:</p>\n\n<ul>\n<li>Histogram of the latent U values.</li>\n<li>QQ-plot with simulation-based confidence bands under a logistic reference.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">confidence</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">simulations</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.plot_hdag", "modulename": "tramdag", "qualname": "TramDagModel.plot_hdag", "kind": "function", "doc": "<p>Visualize the transformation function h() for selected DAG nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input data containing node values or model predictions.\nvariables : list of str or None, optional\n    Names of nodes to visualize. If None, all nodes in <code>self.models</code>\n    are considered.\nplot_n_rows : int, optional\n    Maximum number of rows from <code>df</code> to visualize. Default is 1.\n**kwargs\n    Additional keyword arguments forwarded to the underlying plotting\n    helpers (<code>show_hdag_continous</code> / <code>show_hdag_ordinal</code>).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>For continuous outcomes, <code>show_hdag_continous</code> is called.</li>\n<li>For ordinal outcomes, <code>show_hdag_ordinal</code> is called.</li>\n<li>Nodes that are neither continuous nor ordinal are skipped with a warning.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">variables</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">plot_n_rows</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.sample", "modulename": "tramdag", "qualname": "TramDagModel.sample", "kind": "function", "doc": "<p>Sample from the joint DAG using the trained TRAM models.</p>\n\n<p>Allows for:</p>\n\n<p>Oberservational sampling\nInterventional sampling via <code>do()</code> operations\nCounterfactial sampling using predefined latent draws and do()</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>do_interventions : dict or None, optional\n    Mapping of node names to intervened (fixed) values. For example:\n    <code>{\"x1\": 1.0}</code> represents <code>do(x1 = 1.0)</code>. Default is None.\npredefined_latent_samples_df : pandas.DataFrame or None, optional\n    DataFrame containing columns <code>\"{node}_U\"</code> with predefined latent\n    draws to be used instead of sampling from the prior. Default is None.\n**kwargs\n    Sampling options overriding internal defaults:</p>\n\n<pre><code>number_of_samples : int, default 10000\n    Total number of samples to draw.\nbatch_size : int, default 32\n    Batch size for internal sampling loops.\ndelete_all_previously_sampled : bool, default True\n    If True, delete old sampling files in node-specific sampling\n    directories before writing new ones.\nverbose : bool\n    If True, print informational messages.\ndebug : bool\n    If True, print debug output.\ndevice : {\"auto\", \"cpu\", \"cuda\"}\n    Device selection for sampling.\nuse_initial_weights_for_sampling : bool, default False\n    If True, sample from initial (untrained) model parameters.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple\n    A tuple <code>(sampled_by_node, latents_by_node)</code>:</p>\n\n<pre><code>sampled_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of sampled node values.\nlatents_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of latent U values used.\n</code></pre>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved or if scaling\n    information (<code>self.minmax_dict</code>) is missing.\nRuntimeError\n    If min\u2013max scaling has not been computed before calling <code>sample</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">do_interventions</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">predefined_latent_samples_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.load_sampled_and_latents", "modulename": "tramdag", "qualname": "TramDagModel.load_sampled_and_latents", "kind": "function", "doc": "<p>Load previously stored sampled values and latents for each node.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>EXPERIMENT_DIR : str or None, optional\n    Experiment directory path. If None, it is taken from\n    <code>self.cfg.conf_dict[\"PATHS\"][\"EXPERIMENT_DIR\"]</code>.\nnodes : list of str or None, optional\n    Nodes for which to load samples. If None, use all nodes from\n    <code>self.nodes_dict</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple\n    A tuple <code>(sampled_by_node, latents_by_node)</code>:</p>\n\n<pre><code>sampled_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of sampled values (on CPU).\nlatents_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of latent values (on CPU).\n</code></pre>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved or if no node list\n    is available and <code>nodes</code> is None.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Nodes without both <code>sampled.pt</code> and <code>latents.pt</code> files are skipped\nwith a warning.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">EXPERIMENT_DIR</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">nodes</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.plot_samples_vs_true", "modulename": "tramdag", "qualname": "TramDagModel.plot_samples_vs_true", "kind": "function", "doc": "<p>Compare sampled vs. observed distributions for selected nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Data frame containing the observed node values.\nsampled : dict or None, optional\n    Optional mapping <code>{node_name: array-like or torch.Tensor}</code> of sampled\n    values. If None or if a node is missing, samples are loaded from\n    <code>EXPERIMENT_DIR/{node}/sampling/sampled.pt</code>.\nvariable : list of str or None, optional\n    Subset of nodes to plot. If None, all nodes in the configuration\n    are considered.\nbins : int, optional\n    Number of histogram bins for continuous variables. Default is 100.\nhist_true_color : str, optional\n    Color name for the histogram of true values. Default is \"blue\".\nhist_est_color : str, optional\n    Color name for the histogram of sampled values. Default is \"orange\".\nfigsize : tuple, optional\n    Figure size for the matplotlib plots. Default is (14, 5).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Continuous outcomes: histogram overlay + QQ-plot.</li>\n<li>Ordinal outcomes: side-by-side bar plot of relative frequencies.</li>\n<li>Other categorical outcomes: side-by-side bar plot with category labels.</li>\n<li>If samples are probabilistic (2D tensor), the argmax across classes is used.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">sampled</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bins</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">hist_true_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;blue&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">hist_est_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;orange&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">figsize</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">14</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.nll", "modulename": "tramdag", "qualname": "TramDagModel.nll", "kind": "function", "doc": "<p>Compute the Negative Log-Likelihood (NLL) for all or selected TRAM nodes.</p>\n\n<p>This function evaluates trained TRAM models for each specified variable (node) \non the provided dataset. It performs forward passes only\u2014no training, no weight \nupdates\u2014and returns the mean NLL per node.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : object\n    Input dataset or data source compatible with <code>_ensure_dataset</code>, containing \n    both inputs and targets for each node.\nvariables : list[str], optional\n    List of variable (node) names to evaluate. If None, all nodes in \n    <code>self.models</code> are evaluated.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict[str, float]\n    Dictionary mapping each node name to its average NLL value.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Each model is evaluated independently on its respective DataLoader.</li>\n<li>The normalization values (<code>min_max</code>) for each node are retrieved from \n<code>self.minmax_dict[node]</code>.</li>\n<li>The function uses <code>evaluate_tramdag_model()</code> for per-node evaluation.</li>\n<li>Expected directory structure:\n    <code>&lt;EXPERIMENT_DIR&gt;/&lt;node&gt;/</code>\nwhere each node directory contains the trained model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">variables</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.get_train_val_nll", "modulename": "tramdag", "qualname": "TramDagModel.get_train_val_nll", "kind": "function", "doc": "<p>Retrieve training and validation NLL for a node and a given model state.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : str\n    Node name.\nmode : {\"best\", \"last\", \"init\"}\n    State of interest:\n    - \"best\": epoch with lowest validation NLL.\n    - \"last\": final epoch.\n    - \"init\": first epoch (index 0).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of (float or None, float or None)\n    A tuple <code>(train_nll, val_nll)</code> for the requested mode.\n    Returns <code>(None, None)</code> if loss files are missing or cannot be read.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This method expects per-node JSON files:</p>\n\n<ul>\n<li><code>train_loss_hist.json</code></li>\n<li><code>val_loss_hist.json</code></li>\n</ul>\n\n<p>in the node directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.get_thetas", "modulename": "tramdag", "qualname": "TramDagModel.get_thetas", "kind": "function", "doc": "<p>Return transformed intercept (theta) parameters for a node and state.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : str\n    Node name.\nstate : {\"best\", \"last\", \"init\"}, optional\n    Model state for which to return parameters. Default is \"best\".</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Any or None\n    Transformed theta parameters for the requested node and state.\n    The exact structure (scalar, list, or other) depends on the model.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If an invalid state is given (not in {\"best\", \"last\", \"init\"}).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Intercept dictionaries are cached on the instance under the attribute\n<code>intercept_dicts</code>. If missing or incomplete, they are recomputed using\n<code>get_simple_intercepts_dict</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;best&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.get_linear_shifts", "modulename": "tramdag", "qualname": "TramDagModel.get_linear_shifts", "kind": "function", "doc": "<p>Return learned linear shift terms for a node and a given state.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : str\n    Node name.\nstate : {\"best\", \"last\", \"init\"}, optional\n    Model state for which to return linear shift terms. Default is \"best\".</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict or Any or None\n    Linear shift terms for the given node and state. Usually a dict\n    mapping term names to weights.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If an invalid state is given (not in {\"best\", \"last\", \"init\"}).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Linear shift dictionaries are cached on the instance under the attribute\n<code>linear_shift_dicts</code>. If missing or incomplete, they are recomputed using\n<code>get_linear_shifts_dict</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;best&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.get_linear_shifts_dict", "modulename": "tramdag", "qualname": "TramDagModel.get_linear_shifts_dict", "kind": "function", "doc": "<p>Compute linear shift term dictionaries for all nodes and states.</p>\n\n<p>For each node and each available state (\"best\", \"last\", \"init\"), this\nmethod loads the corresponding model checkpoint, extracts linear shift\nweights from the TRAM model, and stores them in a nested dictionary.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Nested dictionary of the form:</p>\n\n<pre><code>```python\n</code></pre>\n\n<p>{\n    \"best\": {node: {...}},\n    \"last\": {node: {...}},\n    \"init\": {node: {...}},\n}\n```</p>\n\n<pre><code>where the innermost dict maps term labels (e.g. ``\"ls(parent_name)\"``)\nto their weights.\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>If \"best\" or \"last\" checkpoints are unavailable for a node, only\nthe \"init\" entry is populated.</li>\n<li>Empty outer states (without any nodes) are removed from the result.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.get_simple_intercepts_dict", "modulename": "tramdag", "qualname": "TramDagModel.get_simple_intercepts_dict", "kind": "function", "doc": "<p>Compute transformed simple intercept dictionaries for all nodes and states.</p>\n\n<p>For each node and each available state (\"best\", \"last\", \"init\"), this\nmethod loads the corresponding model checkpoint, extracts simple intercept\nweights, transforms them into interpretable theta parameters, and stores\nthem in a nested dictionary.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Nested dictionary of the form:</p>\n\n<pre><code>```python\n</code></pre>\n\n<p>{\n    \"best\": {node: [[theta_1], [theta_2], ...]},\n    \"last\": {node: [[theta_1], [theta_2], ...]},\n    \"init\": {node: [[theta_1], [theta_2], ...]},\n}\n```</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>For ordinal models (<code>self.is_ontram == True</code>), <code>transform_intercepts_ordinal</code>\nis used.</li>\n<li>For continuous models, <code>transform_intercepts_continous</code> is used.</li>\n<li>Empty outer states (without any nodes) are removed from the result.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.summary", "modulename": "tramdag", "qualname": "TramDagModel.summary", "kind": "function", "doc": "<p>Print a multi-part textual summary of the TramDagModel.</p>\n\n<p>The summary includes:</p>\n\n<ol>\n<li>Training metrics overview per node (best/last NLL, epochs).</li>\n<li>Node-specific details (thetas, linear shifts, optional architecture).</li>\n<li>Basic information about the attached training DataFrame, if present.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>verbose : bool, optional\n    If True, include extended per-node details such as the model\n    architecture, parameter count, and availability of checkpoints\n    and sampling results. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This method prints to stdout and does not return structured data.\nIt is intended for quick, human-readable inspection of the current\ntraining and model state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig", "modulename": "tramdag.TramDagConfig", "kind": "module", "doc": "<p>Copyright 2025 Zurich University of Applied Sciences (ZHAW)\nPascal Buehler, Beate Sick, Oliver Duerr</p>\n\n<p>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at</p>\n\n<pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre>\n\n<p>Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.</p>\n"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig", "kind": "class", "doc": "<p>Configuration manager for TRAM-DAG experiments.</p>\n\n<p>This class encapsulates:</p>\n\n<ul>\n<li>The experiment configuration dictionary (<code>conf_dict</code>).</li>\n<li>Its backing file path (<code>CONF_DICT_PATH</code>).</li>\n<li>Utilities to load, validate, modify, and persist configuration.</li>\n<li>DAG visualization and interactive editing helpers.</li>\n</ul>\n\n<h2 id=\"typical-usage\">Typical usage</h2>\n\n<ul>\n<li>Load existing configuration from disk via <code>TramDagConfig.load_json</code>.</li>\n<li>Or create/reuse experiment setup via <code>TramDagConfig().setup_configuration</code>.</li>\n<li>Update sections such as <code>data_type</code>, adjacency matrix, and neural network\nmodel names using the provided methods.</li>\n</ul>\n"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.__init__", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.__init__", "kind": "function", "doc": "<p>Initialize a TramDagConfig instance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>conf_dict : dict or None, optional\n    Configuration dictionary. If None, an empty dict is used and can\n    be populated later. Default is None.\nCONF_DICT_PATH : str or None, optional\n    Path to the configuration file on disk. Default is None.\n_verify : bool, optional\n    If True, run <code>_verify_completeness()</code> after initialization.\n    Default is False.\n**kwargs\n    Additional attributes to be set on the instance. Keys \"conf_dict\"\n    and \"CONF_DICT_PATH\" are forbidden and raise a ValueError.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If any key in <code>kwargs</code> is \"conf_dict\" or \"CONF_DICT_PATH\".</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>By default, <code>debug</code> and <code>verbose</code> are set to False. They can be\noverridden via <code>kwargs</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">conf_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">_verify</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.debug", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.debug", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.verbose", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.conf_dict", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.conf_dict", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.CONF_DICT_PATH", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.CONF_DICT_PATH", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.load_json", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.load_json", "kind": "function", "doc": "<p>Load a configuration from a JSON file and construct a TramDagConfig.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str\n    Path to the configuration JSON file.\ndebug : bool, optional\n    If True, initialize the instance with <code>debug=True</code>. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagConfig\n    Newly created configuration instance with <code>conf_dict</code> loaded from\n    <code>CONF_DICT_PATH</code> and <code>_verify_completeness()</code> executed.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>FileNotFoundError\n    If the configuration file cannot be found (propagated by\n    <code>load_configuration_dict</code>).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">debug</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.update", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.update", "kind": "function", "doc": "<p>Reload the latest configuration from disk into this instance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>None</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is not set on the instance.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The current in-memory <code>conf_dict</code> is overwritten by the contents\nloaded from <code>CONF_DICT_PATH</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.save", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.save", "kind": "function", "doc": "<p>Persist the current configuration dictionary to disk.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str or None, optional\n    Target path for the configuration file. If None, uses\n    <code>self.CONF_DICT_PATH</code>. Default is None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If neither the function argument nor <code>self.CONF_DICT_PATH</code>\n    provides a valid path.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The resulting file is written via <code>write_configuration_dict</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.compute_levels", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.compute_levels", "kind": "function", "doc": "<p>Infer and update ordinal/categorical levels from data.</p>\n\n<p>For each variable in the configuration's <code>data_type</code> section, this\nmethod uses the provided DataFrame to construct a levels dictionary\nand injects the corresponding \"levels\" entry into <code>conf_dict[\"nodes\"]</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    DataFrame used to infer levels for configured variables.\nwrite : bool, optional\n    If True and <code>CONF_DICT_PATH</code> is set, the updated configuration is\n    written back to disk. Default is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>Exception\n    If saving the configuration fails when <code>write=True</code>.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Variables present in <code>levels_dict</code> but not in <code>conf_dict[\"nodes\"]</code>\ntrigger a warning and are skipped.</li>\n<li>If <code>self.verbose</code> or <code>self.debug</code> is True, a success message is printed\nwhen the configuration is saved.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">write</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.plot_dag", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.plot_dag", "kind": "function", "doc": "<p>Visualize the DAG defined by the configuration.</p>\n\n<p>Nodes are categorized and colored as:</p>\n\n<ul>\n<li>Source nodes (no incoming edges): green.</li>\n<li>Sink nodes (no outgoing edges): red.</li>\n<li>Intermediate nodes: light blue.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>seed : int, optional\n    Random seed for layout stability in the spring layout fallback.\n    Default is 42.\ncausal_order : bool, optional\n    If True, attempt to use Graphviz 'dot' layout via\n    <code>networkx.nx_agraph.graphviz_layout</code> to preserve causal ordering.\n    If False or if Graphviz is unavailable, use <code>spring_layout</code>.\n    Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>adj_matrix</code> or <code>data_type</code> is missing or inconsistent with each other,\n    or if the adjacency matrix fails validation.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Edge labels are colored by prefix:</p>\n\n<ul>\n<li>\"ci\": blue</li>\n<li>\"ls\": red</li>\n<li>\"cs\": green</li>\n<li>other: black</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">42</span>, </span><span class=\"param\"><span class=\"n\">causal_order</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.setup_configuration", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.setup_configuration", "kind": "function", "doc": "<p>Create or reuse a configuration for an experiment.</p>\n\n<p>This method behaves differently depending on how it is called:</p>\n\n<ol>\n<li>Class call (e.g. <code>TramDagConfig.setup_configuration(...)</code>):</li>\n</ol>\n\n<ul>\n<li>Creates or loads a configuration at the resolved path.</li>\n<li>Returns a new <code>TramDagConfig</code> instance.</li>\n</ul>\n\n<ol start=\"2\">\n<li>Instance call (e.g. <code>cfg.setup_configuration(...)</code>):</li>\n</ol>\n\n<ul>\n<li>Updates <code>self.conf_dict</code> and <code>self.CONF_DICT_PATH</code> in place.</li>\n<li>Optionally verifies completeness.</li>\n<li>Returns None.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>experiment_name : str or None, optional\n    Name of the experiment. If None, defaults to \"experiment_1\".\nEXPERIMENT_DIR : str or None, optional\n    Directory for the experiment. If None, defaults to\n    <code>&lt;cwd&gt;/&lt;experiment_name&gt;</code>.\ndebug : bool, optional\n    If True, initialize / update with <code>debug=True</code>. Default is False.\n_verify : bool, optional\n    If True, call <code>_verify_completeness()</code> after loading. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagConfig or None\n    - A new instance when called on the class.\n    - None when called on an existing instance.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>A configuration file named \"configuration.json\" is created if it does\nnot exist yet.</li>\n<li>Underlying creation uses <code>create_and_write_new_configuration_dict</code>\nand <code>load_configuration_dict</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">experiment_name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">EXPERIMENT_DIR</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">_verify</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.set_data_type", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.set_data_type", "kind": "function", "doc": "<p>Update or write the <code>data_type</code> section of a configuration file.</p>\n\n<p>Supports both class-level and instance-level usage:</p>\n\n<ul>\n<li>Class call:</li>\n<li>Requires <code>CONF_DICT_PATH</code> argument.</li>\n<li>Reads the file if it exists, or starts from an empty dict.</li>\n<li><p>Writes updated configuration to <code>CONF_DICT_PATH</code>.</p></li>\n<li><p>Instance call:</p></li>\n<li>Uses <code>self.CONF_DICT_PATH</code> if available, otherwise defaults to\n<code>&lt;cwd&gt;/configuration.json</code> if no path is provided.</li>\n<li>Updates <code>self.conf_dict</code> and <code>self.CONF_DICT_PATH</code> after writing.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data_type : dict\n    Mapping <code>{variable_name: type_spec}</code>, where <code>type_spec</code> encodes\n    modeling types (e.g. continuous, ordinal, etc.).\nCONF_DICT_PATH : str or None, optional\n    Path to the configuration file. Must be provided for class calls.\n    For instance calls, defaults as described above.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is missing when called on the class, or if\n    validation of data types fails.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Variable names are validated via <code>validate_variable_names</code>.</li>\n<li>Data type values are validated via <code>validate_data_types</code>.</li>\n<li>A textual summary of modeling settings is printed via\n<code>print_data_type_modeling_setting</code>, if possible.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.set_meta_adj_matrix", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.set_meta_adj_matrix", "kind": "function", "doc": "<p>Launch the interactive editor to set or modify the adjacency matrix.</p>\n\n<p>This method:</p>\n\n<ol>\n<li>Resolves the configuration path either from the argument or, for\ninstances, from <code>self.CONF_DICT_PATH</code>.</li>\n<li>Invokes <code>interactive_adj_matrix</code> to edit the adjacency matrix.</li>\n<li>For instances, reloads the updated configuration into <code>self.conf_dict</code>.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str or None, optional\n    Path to the configuration file. Must be provided when called\n    on the class. For instance calls, defaults to <code>self.CONF_DICT_PATH</code>.\nseed : int, optional\n    Random seed for any layout or stochastic behavior in the interactive\n    editor. Default is 5.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is not provided and cannot be inferred\n    (e.g. in a class call without path).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><code>self.update()</code> is called at the start to ensure the in-memory config\nis in sync with the file before launching the editor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagConfig.TramDagConfig.set_tramdag_nn_models", "modulename": "tramdag.TramDagConfig", "qualname": "TramDagConfig.set_tramdag_nn_models", "kind": "function", "doc": "<p>Launch the interactive editor to set TRAM-DAG neural network model names.</p>\n\n<p>Depending on call context:</p>\n\n<ul>\n<li>Class call:</li>\n<li>Requires <code>CONF_DICT_PATH</code> argument.</li>\n<li><p>Returns nothing and does not modify a specific instance.</p></li>\n<li><p>Instance call:</p></li>\n<li>Resolves <code>CONF_DICT_PATH</code> from the argument or <code>self.CONF_DICT_PATH</code>.</li>\n<li>Updates <code>self.conf_dict</code> and <code>self.CONF_DICT_PATH</code> if the editor\nreturns an updated configuration.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>CONF_DICT_PATH : str or None, optional\n    Path to the configuration file. Must be provided when called on\n    the class. For instance calls, defaults to <code>self.CONF_DICT_PATH</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>CONF_DICT_PATH</code> is not provided and cannot be inferred\n    (e.g. in a class call without path).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The interactive editor is invoked via <code>interactive_nn_names_matrix</code>.\nIf it returns <code>None</code>, the instance configuration is left unchanged.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">CONF_DICT_PATH</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagDataset", "modulename": "tramdag.TramDagDataset", "kind": "module", "doc": "<p>Copyright 2025 Zurich University of Applied Sciences (ZHAW)\nPascal Buehler, Beate Sick, Oliver Duerr</p>\n\n<p>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at</p>\n\n<pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre>\n\n<p>Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.</p>\n"}, {"fullname": "tramdag.TramDagDataset.TramDagDataset", "modulename": "tramdag.TramDagDataset", "qualname": "TramDagDataset", "kind": "class", "doc": "<h1 id=\"tramdagdataset\">TramDagDataset</h1>\n\n<p>The <code>TramDagDataset</code> class handles structured data preparation for TRAM-DAG\nmodels. It wraps a pandas DataFrame together with its configuration and provides\nutilities for scaling, transformation, and efficient DataLoader construction\nfor each node in a DAG-based configuration.</p>\n\n<hr />\n\n<h2 id=\"core-responsibilities\">Core Responsibilities</h2>\n\n<ul>\n<li>Validate and store configuration metadata (<code>TramDagConfig</code>).</li>\n<li>Manage per-node settings for DataLoader creation (batch size, shuffling, workers).</li>\n<li>Compute scaling information (quantile-based min/max).</li>\n<li>Optionally precompute and cache dataset representations.</li>\n<li>Expose PyTorch Dataset and DataLoader interfaces for model training.</li>\n</ul>\n\n<hr />\n\n<h2 id=\"key-attributes\">Key Attributes</h2>\n\n<ul>\n<li><p><strong>df</strong> : pandas.DataFrame<br />\nThe dataset content used for building loaders and computing scaling.</p></li>\n<li><p><strong>cfg</strong> : TramDagConfig<br />\nConfiguration object defining nodes and variable metadata.</p></li>\n<li><p><strong>nodes_dict</strong> : dict<br />\nMapping of variable names to node specifications from the configuration.</p></li>\n<li><p><strong>loaders</strong> : dict<br />\nMapping of node names to <code>torch.utils.data.DataLoader</code> instances or <code>GenericDataset</code> objects.</p></li>\n<li><p><strong>DEFAULTS</strong> : dict<br />\nDefault DataLoader and dataset-related settings (e.g., batch_size, shuffle, num_workers, etc.).</p></li>\n</ul>\n\n<hr />\n\n<h2 id=\"main-methods\">Main Methods</h2>\n\n<ul>\n<li><p><strong>from_dataframe(df, cfg, **kwargs)</strong><br />\nConstruct the dataset directly from a pandas DataFrame.</p></li>\n<li><p><strong>compute_scaling(df=None, write=True)</strong><br />\nCompute per-variable min/max scaling values from data.</p></li>\n<li><p><strong>summary()</strong><br />\nPrint dataset overview including shape, dtypes, statistics, and node settings.</p></li>\n</ul>\n\n<hr />\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Intended for training data; <code>compute_scaling()</code> should use only training subsets.</li>\n<li>Compatible with both CPU and GPU DataLoader options.</li>\n<li>Strict validation of keyword arguments against <code>DEFAULTS</code> prevents silent misconfiguration.</li>\n</ul>\n\n<hr />\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cfg</span> <span class=\"o\">=</span> <span class=\"n\">TramDagConfig</span><span class=\"o\">.</span><span class=\"n\">from_json</span><span class=\"p\">(</span><span class=\"s2\">&quot;config.json&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dataset</span> <span class=\"o\">=</span> <span class=\"n\">TramDagDataset</span><span class=\"o\">.</span><span class=\"n\">from_dataframe</span><span class=\"p\">(</span><span class=\"n\">train_df</span><span class=\"p\">,</span> <span class=\"n\">cfg</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">1024</span><span class=\"p\">,</span> <span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dataset</span><span class=\"o\">.</span><span class=\"n\">summary</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">minmax</span> <span class=\"o\">=</span> <span class=\"n\">dataset</span><span class=\"o\">.</span><span class=\"n\">compute_scaling</span><span class=\"p\">(</span><span class=\"n\">train_df</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">loader</span> <span class=\"o\">=</span> <span class=\"n\">dataset</span><span class=\"o\">.</span><span class=\"n\">loaders</span><span class=\"p\">[</span><span class=\"s2\">&quot;variable_x&quot;</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">loader</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n", "bases": "typing.Generic[+_T_co]"}, {"fullname": "tramdag.TramDagDataset.TramDagDataset.__init__", "modulename": "tramdag.TramDagDataset", "qualname": "TramDagDataset.__init__", "kind": "function", "doc": "<p>Initialize an empty TramDagDataset shell.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This constructor does not attach data or configuration. Use\n<code>TramDagDataset.from_dataframe</code> to obtain a ready-to-use instance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "tramdag.TramDagDataset.TramDagDataset.DEFAULTS", "modulename": "tramdag.TramDagDataset", "qualname": "TramDagDataset.DEFAULTS", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;batch_size&#x27;: 32000, &#x27;shuffle&#x27;: True, &#x27;num_workers&#x27;: 4, &#x27;pin_memory&#x27;: True, &#x27;return_intercept_shift&#x27;: True, &#x27;debug&#x27;: False, &#x27;transform&#x27;: None, &#x27;use_dataloader&#x27;: True, &#x27;use_precomputed&#x27;: False, &#x27;sampler&#x27;: None, &#x27;batch_sampler&#x27;: None, &#x27;collate_fn&#x27;: None, &#x27;drop_last&#x27;: False, &#x27;timeout&#x27;: 0, &#x27;worker_init_fn&#x27;: None, &#x27;multiprocessing_context&#x27;: None, &#x27;generator&#x27;: None, &#x27;prefetch_factor&#x27;: 2, &#x27;persistent_workers&#x27;: True, &#x27;pin_memory_device&#x27;: &#x27;&#x27;}"}, {"fullname": "tramdag.TramDagDataset.TramDagDataset.from_dataframe", "modulename": "tramdag.TramDagDataset", "qualname": "TramDagDataset.from_dataframe", "kind": "function", "doc": "<p>Create a TramDagDataset instance directly from a pandas DataFrame.</p>\n\n<p>This classmethod:</p>\n\n<ol>\n<li>Validates keyword arguments against <code>DEFAULTS</code>.</li>\n<li>Merges user overrides with defaults into a resolved settings dict.</li>\n<li>Stores the configuration and verifies its completeness.</li>\n<li>Applies settings to the instance.</li>\n<li>Builds per-node datasets and DataLoaders.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input DataFrame containing the dataset.\ncfg : TramDagConfig\n    Configuration object defining nodes and variable metadata.\n**kwargs\n    Optional overrides for <code>DEFAULTS</code>. All keys must exist in\n    <code>TramDagDataset.DEFAULTS</code>. Common keys include:</p>\n\n<pre><code>batch_size : int\n    Batch size for DataLoaders.\nshuffle : bool\n    Whether to shuffle samples per epoch.\nnum_workers : int\n    Number of DataLoader workers.\npin_memory : bool\n    Whether to pin memory for faster host-to-device transfers.\nreturn_intercept_shift : bool\n    Whether datasets should return intercept/shift information.\ndebug : bool\n    Enable debug printing.\ntransform : callable or dict or None\n    Optional transform(s) applied to samples.\nuse_dataloader : bool\n    If True, construct DataLoaders; else store raw Dataset objects.\nuse_precomputed : bool\n    If True, precompute dataset representation to disk and reload it.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagDataset\n    Initialized dataset instance.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If <code>df</code> is not a pandas DataFrame.\nValueError\n    If unknown keyword arguments are provided (when validation is enabled).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If <code>shuffle=True</code> and the inferred variable name of <code>df</code> suggests\nvalidation/test data (e.g. \"val\", \"test\"), a warning is printed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">cfg</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagDataset.TramDagDataset.compute_scaling", "modulename": "tramdag.TramDagDataset", "qualname": "TramDagDataset.compute_scaling", "kind": "function", "doc": "<p>Compute variable-wise scaling parameters from data.</p>\n\n<p>Per variable, this method computes approximate minimum and maximum\nvalues using the 5th and 95th percentiles. This is typically used\nto derive robust normalization/clipping ranges from training data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame or None, optional\n    DataFrame used to compute scaling. If None, <code>self.df</code> is used.\nwrite : bool, optional\n    Unused placeholder for interface compatibility with other components.\n    Kept for potential future extensions. Default is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Mapping <code>{column_name: [min_value, max_value]}</code>, where values\n    are derived from the 0.05 and 0.95 quantiles.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If <code>self.debug</code> is True, the method emits debug messages about the\ndata source. Only training data should be used to avoid leakage.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">write</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagDataset.TramDagDataset.summary", "modulename": "tramdag.TramDagDataset", "qualname": "TramDagDataset.summary", "kind": "function", "doc": "<p>Print a structured overview of the dataset and configuration.</p>\n\n<p>The summary includes:</p>\n\n<ol>\n<li>DataFrame information:</li>\n</ol>\n\n<ul>\n<li>Shape</li>\n<li>Columns</li>\n<li>Head (first rows)</li>\n<li>Dtypes</li>\n<li>Descriptive statistics</li>\n</ul>\n\n<ol start=\"2\">\n<li>Configuration overview:</li>\n</ol>\n\n<ul>\n<li>Number of nodes</li>\n<li>Loader mode (DataLoader vs. raw Dataset)</li>\n<li>Precomputation status</li>\n</ul>\n\n<ol start=\"3\">\n<li>Node settings:</li>\n</ol>\n\n<ul>\n<li>Batch size</li>\n<li>Shuffle flag</li>\n<li>num_workers</li>\n<li>pin_memory</li>\n<li>return_intercept_shift</li>\n<li>debug</li>\n<li>transform</li>\n</ul>\n\n<ol start=\"4\">\n<li>DataLoader overview:</li>\n</ol>\n\n<ul>\n<li>Type and length of each loader.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>None</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Intended for quick inspection and debugging. Uses <code>print</code> statements\nand does not return structured metadata.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel", "modulename": "tramdag.TramDagModel", "kind": "module", "doc": "<p>Copyright 2025 Zurich University of Applied Sciences (ZHAW)\nPascal Buehler, Beate Sick, Oliver Duerr</p>\n\n<p>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at</p>\n\n<pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre>\n\n<p>Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.</p>\n"}, {"fullname": "tramdag.TramDagModel.TramDagModel", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel", "kind": "class", "doc": "<p>Probabilistic DAG model built from node-wise TRAMs (transformation models).</p>\n\n<p>This class manages:</p>\n\n<ul>\n<li>Configuration and per-node model construction.</li>\n<li>Data scaling (min\u2013max).</li>\n<li>Training (sequential or per-node parallel on CPU).</li>\n<li>Diagnostics (loss history, intercepts, linear shifts, latents).</li>\n<li>Sampling from the joint DAG and loading stored samples.</li>\n<li>High-level summaries and plotting utilities.</li>\n</ul>\n"}, {"fullname": "tramdag.TramDagModel.TramDagModel.__init__", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.__init__", "kind": "function", "doc": "<p>Initialize an empty TramDagModel shell.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This constructor does not build any node models and does not attach a\nconfiguration. Use <code>TramDagModel.from_config</code> or <code>TramDagModel.from_directory</code>\nto obtain a fully configured and ready-to-use instance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "tramdag.TramDagModel.TramDagModel.DEFAULTS_CONFIG", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.DEFAULTS_CONFIG", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;set_initial_weights&#x27;: False, &#x27;debug&#x27;: False, &#x27;verbose&#x27;: False, &#x27;device&#x27;: &#x27;auto&#x27;, &#x27;initial_data&#x27;: None, &#x27;overwrite_initial_weights&#x27;: True}"}, {"fullname": "tramdag.TramDagModel.TramDagModel.DEFAULTS_FIT", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.DEFAULTS_FIT", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;epochs&#x27;: 100, &#x27;train_list&#x27;: None, &#x27;callbacks&#x27;: None, &#x27;learning_rate&#x27;: 0.01, &#x27;device&#x27;: &#x27;auto&#x27;, &#x27;optimizers&#x27;: None, &#x27;schedulers&#x27;: None, &#x27;use_scheduler&#x27;: False, &#x27;save_linear_shifts&#x27;: True, &#x27;save_simple_intercepts&#x27;: True, &#x27;debug&#x27;: False, &#x27;verbose&#x27;: True, &#x27;train_mode&#x27;: &#x27;sequential&#x27;, &#x27;return_history&#x27;: False, &#x27;overwrite_inital_weights&#x27;: True, &#x27;num_workers&#x27;: 4, &#x27;persistent_workers&#x27;: True, &#x27;prefetch_factor&#x27;: 4, &#x27;batch_size&#x27;: 1000}"}, {"fullname": "tramdag.TramDagModel.TramDagModel.debug", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.debug", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagModel.TramDagModel.verbose", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagModel.TramDagModel.device", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.device", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tramdag.TramDagModel.TramDagModel.get_device", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.get_device", "kind": "function", "doc": "<p>Resolve the target device string from a settings dictionary.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>settings : dict\n    Dictionary containing at least a key <code>\"device\"</code> with one of\n    {\"auto\", \"cpu\", \"cuda\"}. If missing, \"auto\" is assumed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Device string, either \"cpu\" or \"cuda\".</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If <code>device == \"auto\"</code>, CUDA is selected if available, otherwise CPU.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">settings</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.from_config", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.from_config", "kind": "function", "doc": "<p>Construct a TramDagModel from a TramDagConfig object.</p>\n\n<p>This builds one TRAM model per node in the DAG and optionally writes\nthe initial model parameters to disk.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cfg : TramDagConfig\n    Configuration wrapper holding the underlying configuration dictionary,\n    including at least:\n    - <code>conf_dict[\"nodes\"]</code>: mapping of node names to node configs.\n    - <code>conf_dict[\"PATHS\"][\"EXPERIMENT_DIR\"]</code>: experiment directory.\n**kwargs\n    Node-level construction options. Each key must be present in\n    <code>DEFAULTS_CONFIG</code>. Values can be:\n    - scalar: applied to all nodes.\n    - dict: mapping <code>{node_name: value}</code> for per-node overrides.</p>\n\n<pre><code>Common keys include:\ndevice : {\"auto\", \"cpu\", \"cuda\"}, default \"auto\"\n    Device selection (CUDA if available when \"auto\").\ndebug : bool, default False\n    If True, print debug messages.\nverbose : bool, default False\n    If True, print informational messages.\nset_initial_weights : bool\n    Passed to underlying TRAM model constructors.\noverwrite_initial_weights : bool, default True\n    If True, overwrite any existing ``initial_model.pt`` files per node.\ninitial_data : Any\n    Optional object passed down to node constructors.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagModel\n    Fully initialized instance with:\n    - <code>cfg</code>\n    - <code>nodes_dict</code>\n    - <code>models</code> (per-node TRAMs)\n    - <code>settings</code> (resolved per-node config)</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If any dict-valued kwarg does not provide values for exactly the set\n    of nodes in <code>cfg.conf_dict[\"nodes\"]</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">cfg</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.from_directory", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.from_directory", "kind": "function", "doc": "<p>Reconstruct a TramDagModel from an experiment directory on disk.</p>\n\n<p>This method:</p>\n\n<ol>\n<li>Loads the configuration JSON.</li>\n<li>Wraps it in a TramDagConfig.</li>\n<li>Builds all node models via <code>from_config</code>.</li>\n<li>Loads the min\u2013max scaling dictionary.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>EXPERIMENT_DIR : str\n    Path to an experiment directory containing:\n    - <code>configuration.json</code>\n    - <code>min_max_scaling.json</code>.\ndevice : {\"auto\", \"cpu\", \"cuda\"}, optional\n    Device selection. Default is \"auto\".\ndebug : bool, optional\n    If True, enable debug messages. Default is False.\nverbose : bool, optional\n    If True, enable informational messages. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>TramDagModel\n    A TramDagModel instance with models, config, and scaling loaded.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>FileNotFoundError\n    If configuration or min\u2013max files cannot be found.\nRuntimeError\n    If the min\u2013max file cannot be read or parsed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">EXPERIMENT_DIR</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.load_or_compute_minmax", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.load_or_compute_minmax", "kind": "function", "doc": "<p>Load an existing Min\u2013Max scaling dictionary from disk or compute a new one \nfrom the provided training dataset.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>use_existing : bool, optional (default=False)\n    If True, attempts to load an existing <code>min_max_scaling.json</code> file \n    from the experiment directory. Raises an error if the file is missing \n    or unreadable.</p>\n\n<p>write : bool, optional (default=True)\n    If True, writes the computed Min\u2013Max scaling dictionary to \n    <code>&lt;EXPERIMENT_DIR&gt;/min_max_scaling.json</code>.</p>\n\n<p>td_train_data : object, optional\n    Training dataset used to compute scaling statistics. If not provided,\n    the method will ensure or construct it via <code>_ensure_dataset(data=..., is_val=False)</code>.</p>\n\n<h2 id=\"behavior\">Behavior</h2>\n\n<ul>\n<li>If <code>use_existing=True</code>, loads the JSON file containing previously saved \nmin\u2013max values and stores it in <code>self.minmax_dict</code>.</li>\n<li>If <code>use_existing=False</code>, computes a new scaling dictionary using \n<code>td_train_data.compute_scaling()</code> and stores the result in \n<code>self.minmax_dict</code>.</li>\n<li>Optionally writes the computed dictionary to disk.</li>\n</ul>\n\n<h2 id=\"side-effects\">Side Effects</h2>\n\n<ul>\n<li>Populates <code>self.minmax_dict</code> with scaling values.</li>\n<li>Writes or loads the file <code>min_max_scaling.json</code> under \n<code>&lt;EXPERIMENT_DIR&gt;</code>.</li>\n<li>Prints diagnostic output if <code>self.debug</code> or <code>self.verbose</code> is True.</li>\n</ul>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>FileNotFoundError\n    If <code>use_existing=True</code> but the min\u2013max file does not exist.</p>\n\n<p>RuntimeError\n    If an existing min\u2013max file cannot be read or parsed.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The computed min\u2013max dictionary is expected to contain scaling statistics \nper feature, typically in the form:\n    {\n        \"node\": {\"min\": float, \"max\": float},\n        ...\n    }</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">td_train_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">use_existing</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">write</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.fit", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.fit", "kind": "function", "doc": "<p>Train TRAM models for all nodes in the DAG.</p>\n\n<p>Coordinates dataset preparation, min\u2013max scaling, and per-node training,\noptionally in parallel on CPU.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>train_data : pandas.DataFrame or TramDagDataset\n    Training data. If a DataFrame is given, it is converted into a\n    TramDagDataset using <code>_ensure_dataset</code>.\nval_data : pandas.DataFrame or TramDagDataset or None, optional\n    Validation data. If a DataFrame is given, it is converted into a\n    TramDagDataset. If None, no validation loss is computed.\n**kwargs\n    Overrides for <code>DEFAULTS_FIT</code>. All keys must exist in\n    <code>DEFAULTS_FIT</code>. Common options:</p>\n\n<pre><code>epochs : int, default 100\n    Number of training epochs per node.\nlearning_rate : float, default 0.01\n    Learning rate for the default Adam optimizer.\ntrain_list : list of str or None, optional\n    List of node names to train. If None, all nodes are trained.\ntrain_mode : {\"sequential\", \"parallel\"}, default \"sequential\"\n    Training mode. \"parallel\" uses joblib-based CPU multiprocessing.\n    GPU forces sequential mode.\ndevice : {\"auto\", \"cpu\", \"cuda\"}, default \"auto\"\n    Device selection.\noptimizers : dict or None\n    Optional mapping ``{node_name: optimizer}``. If provided for a\n    node, that optimizer is used instead of creating a new Adam.\nschedulers : dict or None\n    Optional mapping ``{node_name: scheduler}``.\nuse_scheduler : bool\n    If True, enable scheduler usage in the training loop.\nnum_workers : int\n    DataLoader workers in sequential mode (ignored in parallel).\npersistent_workers : bool\n    DataLoader persistence in sequential mode (ignored in parallel).\nprefetch_factor : int\n    DataLoader prefetch factor (ignored in parallel).\nbatch_size : int\n    Batch size for all node DataLoaders.\ndebug : bool\n    Enable debug output.\nverbose : bool\n    Enable informational logging.\nreturn_history : bool\n    If True, return a history dict.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict or None\n    If <code>return_history=True</code>, a dictionary mapping each node name\n    to its training history. Otherwise, returns None.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>train_mode</code> is not \"sequential\" or \"parallel\".</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">train_data</span>, </span><span class=\"param\"><span class=\"n\">val_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.loss_history", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.loss_history", "kind": "function", "doc": "<p>Load training and validation loss history for all nodes.</p>\n\n<p>Looks for per-node JSON files:</p>\n\n<ul>\n<li><code>EXPERIMENT_DIR/{node}/train_loss_hist.json</code></li>\n<li><code>EXPERIMENT_DIR/{node}/val_loss_hist.json</code></li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A dictionary mapping node names to:</p>\n\n<pre><code>```python\n</code></pre>\n\n<p>{\n    \"train\": list or None,\n    \"validation\": list or None\n}\n```</p>\n\n<pre><code>where each list contains NLL values per epoch, or None if not found.\n</code></pre>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved from the configuration.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.linear_shift_history", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.linear_shift_history", "kind": "function", "doc": "<p>Load linear shift term histories for all nodes.</p>\n\n<p>Each node history is expected in a JSON file named\n<code>linear_shifts_all_epochs.json</code> under the node directory.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A mapping <code>{node_name: pandas.DataFrame}</code>, where each DataFrame\n    contains linear shift weights across epochs.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved from the configuration.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If a history file is missing for a node, a warning is printed and the\nnode is omitted from the returned dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.simple_intercept_history", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.simple_intercept_history", "kind": "function", "doc": "<p>Load simple intercept histories for all nodes.</p>\n\n<p>Each node history is expected in a JSON file named\n<code>simple_intercepts_all_epochs.json</code> under the node directory.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A mapping <code>{node_name: pandas.DataFrame}</code>, where each DataFrame\n    contains intercept weights across epochs.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved from the configuration.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If a history file is missing for a node, a warning is printed and the\nnode is omitted from the returned dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.get_latent", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.get_latent", "kind": "function", "doc": "<p>Compute latent representations for all nodes in the DAG.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input data frame with columns corresponding to nodes in the DAG.\nverbose : bool, optional\n    If True, print informational messages during latent computation.\n    Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas.DataFrame\n    DataFrame containing the original columns plus latent variables\n    for each node (e.g. columns named <code>f\"{node}_U\"</code>).</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory is missing from the configuration or\n    if <code>self.minmax_dict</code> has not been set.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.plot_loss_history", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.plot_loss_history", "kind": "function", "doc": "<p>Plot training and validation loss evolution per node.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>variable : str or None, optional\n    If provided, plot loss history for this node only. If None, plot\n    histories for all nodes that have both train and validation logs.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Two subplots are produced:</p>\n\n<ul>\n<li>Full epoch history.</li>\n<li>Last 10% of epochs (or only the last epoch if fewer than 5 epochs).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.plot_linear_shift_history", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.plot_linear_shift_history", "kind": "function", "doc": "<p>Plot the evolution of linear shift terms over epochs.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data_dict : dict or None, optional\n    Pre-loaded mapping <code>{node_name: pandas.DataFrame}</code> containing shift\n    weights across epochs. If None, <code>linear_shift_history()</code> is called.\nnode : str or None, optional\n    If provided, plot only this node. Otherwise, plot all nodes\n    present in <code>data_dict</code>.\nref_lines : dict or None, optional\n    Optional mapping <code>{node_name: list of float}</code>. For each specified\n    node, horizontal reference lines are drawn at the given values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The function flattens nested list-like entries in the DataFrames to scalars,\nconverts epoch labels to numeric, and then draws one line per shift term.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_dict</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ref_lines</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.plot_simple_intercepts_history", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.plot_simple_intercepts_history", "kind": "function", "doc": "<p>Plot the evolution of simple intercept weights over epochs.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data_dict : dict or None, optional\n    Pre-loaded mapping <code>{node_name: pandas.DataFrame}</code> containing intercept\n    weights across epochs. If None, <code>simple_intercept_history()</code> is called.\nnode : str or None, optional\n    If provided, plot only this node. Otherwise, plot all nodes present\n    in <code>data_dict</code>.\nref_lines : dict or None, optional\n    Optional mapping <code>{node_name: list of float}</code>. For each specified\n    node, horizontal reference lines are drawn at the given values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Nested list-like entries in the DataFrames are reduced to scalars before\nplotting. One line is drawn per intercept parameter.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_dict</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ref_lines</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.plot_latents", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.plot_latents", "kind": "function", "doc": "<p>Visualize latent U distributions for one or all nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input data frame with raw node values.\nvariable : str or None, optional\n    If provided, only this node's latents are plotted. If None, all\n    nodes with latent columns are processed.\nconfidence : float, optional\n    Confidence level for QQ-plot bands (0 &lt; confidence &lt; 1).\n    Default is 0.95.\nsimulations : int, optional\n    Number of Monte Carlo simulations for QQ-plot bands. Default is 1000.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>For each node, two plots are produced:</p>\n\n<ul>\n<li>Histogram of the latent U values.</li>\n<li>QQ-plot with simulation-based confidence bands under a logistic reference.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">confidence</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">simulations</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.plot_hdag", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.plot_hdag", "kind": "function", "doc": "<p>Visualize the transformation function h() for selected DAG nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Input data containing node values or model predictions.\nvariables : list of str or None, optional\n    Names of nodes to visualize. If None, all nodes in <code>self.models</code>\n    are considered.\nplot_n_rows : int, optional\n    Maximum number of rows from <code>df</code> to visualize. Default is 1.\n**kwargs\n    Additional keyword arguments forwarded to the underlying plotting\n    helpers (<code>show_hdag_continous</code> / <code>show_hdag_ordinal</code>).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>For continuous outcomes, <code>show_hdag_continous</code> is called.</li>\n<li>For ordinal outcomes, <code>show_hdag_ordinal</code> is called.</li>\n<li>Nodes that are neither continuous nor ordinal are skipped with a warning.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">variables</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">plot_n_rows</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.sample", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.sample", "kind": "function", "doc": "<p>Sample from the joint DAG using the trained TRAM models.</p>\n\n<p>Allows for:</p>\n\n<p>Oberservational sampling\nInterventional sampling via <code>do()</code> operations\nCounterfactial sampling using predefined latent draws and do()</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>do_interventions : dict or None, optional\n    Mapping of node names to intervened (fixed) values. For example:\n    <code>{\"x1\": 1.0}</code> represents <code>do(x1 = 1.0)</code>. Default is None.\npredefined_latent_samples_df : pandas.DataFrame or None, optional\n    DataFrame containing columns <code>\"{node}_U\"</code> with predefined latent\n    draws to be used instead of sampling from the prior. Default is None.\n**kwargs\n    Sampling options overriding internal defaults:</p>\n\n<pre><code>number_of_samples : int, default 10000\n    Total number of samples to draw.\nbatch_size : int, default 32\n    Batch size for internal sampling loops.\ndelete_all_previously_sampled : bool, default True\n    If True, delete old sampling files in node-specific sampling\n    directories before writing new ones.\nverbose : bool\n    If True, print informational messages.\ndebug : bool\n    If True, print debug output.\ndevice : {\"auto\", \"cpu\", \"cuda\"}\n    Device selection for sampling.\nuse_initial_weights_for_sampling : bool, default False\n    If True, sample from initial (untrained) model parameters.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple\n    A tuple <code>(sampled_by_node, latents_by_node)</code>:</p>\n\n<pre><code>sampled_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of sampled node values.\nlatents_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of latent U values used.\n</code></pre>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved or if scaling\n    information (<code>self.minmax_dict</code>) is missing.\nRuntimeError\n    If min\u2013max scaling has not been computed before calling <code>sample</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">do_interventions</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">predefined_latent_samples_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.load_sampled_and_latents", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.load_sampled_and_latents", "kind": "function", "doc": "<p>Load previously stored sampled values and latents for each node.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>EXPERIMENT_DIR : str or None, optional\n    Experiment directory path. If None, it is taken from\n    <code>self.cfg.conf_dict[\"PATHS\"][\"EXPERIMENT_DIR\"]</code>.\nnodes : list of str or None, optional\n    Nodes for which to load samples. If None, use all nodes from\n    <code>self.nodes_dict</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple\n    A tuple <code>(sampled_by_node, latents_by_node)</code>:</p>\n\n<pre><code>sampled_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of sampled values (on CPU).\nlatents_by_node : dict\n    Mapping ``{node_name: torch.Tensor}`` of latent values (on CPU).\n</code></pre>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the experiment directory cannot be resolved or if no node list\n    is available and <code>nodes</code> is None.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Nodes without both <code>sampled.pt</code> and <code>latents.pt</code> files are skipped\nwith a warning.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">EXPERIMENT_DIR</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">nodes</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.plot_samples_vs_true", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.plot_samples_vs_true", "kind": "function", "doc": "<p>Compare sampled vs. observed distributions for selected nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    Data frame containing the observed node values.\nsampled : dict or None, optional\n    Optional mapping <code>{node_name: array-like or torch.Tensor}</code> of sampled\n    values. If None or if a node is missing, samples are loaded from\n    <code>EXPERIMENT_DIR/{node}/sampling/sampled.pt</code>.\nvariable : list of str or None, optional\n    Subset of nodes to plot. If None, all nodes in the configuration\n    are considered.\nbins : int, optional\n    Number of histogram bins for continuous variables. Default is 100.\nhist_true_color : str, optional\n    Color name for the histogram of true values. Default is \"blue\".\nhist_est_color : str, optional\n    Color name for the histogram of sampled values. Default is \"orange\".\nfigsize : tuple, optional\n    Figure size for the matplotlib plots. Default is (14, 5).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Continuous outcomes: histogram overlay + QQ-plot.</li>\n<li>Ordinal outcomes: side-by-side bar plot of relative frequencies.</li>\n<li>Other categorical outcomes: side-by-side bar plot with category labels.</li>\n<li>If samples are probabilistic (2D tensor), the argmax across classes is used.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">sampled</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bins</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">hist_true_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;blue&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">hist_est_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;orange&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">figsize</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">14</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.nll", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.nll", "kind": "function", "doc": "<p>Compute the Negative Log-Likelihood (NLL) for all or selected TRAM nodes.</p>\n\n<p>This function evaluates trained TRAM models for each specified variable (node) \non the provided dataset. It performs forward passes only\u2014no training, no weight \nupdates\u2014and returns the mean NLL per node.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : object\n    Input dataset or data source compatible with <code>_ensure_dataset</code>, containing \n    both inputs and targets for each node.\nvariables : list[str], optional\n    List of variable (node) names to evaluate. If None, all nodes in \n    <code>self.models</code> are evaluated.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict[str, float]\n    Dictionary mapping each node name to its average NLL value.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Each model is evaluated independently on its respective DataLoader.</li>\n<li>The normalization values (<code>min_max</code>) for each node are retrieved from \n<code>self.minmax_dict[node]</code>.</li>\n<li>The function uses <code>evaluate_tramdag_model()</code> for per-node evaluation.</li>\n<li>Expected directory structure:\n    <code>&lt;EXPERIMENT_DIR&gt;/&lt;node&gt;/</code>\nwhere each node directory contains the trained model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">variables</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.get_train_val_nll", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.get_train_val_nll", "kind": "function", "doc": "<p>Retrieve training and validation NLL for a node and a given model state.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : str\n    Node name.\nmode : {\"best\", \"last\", \"init\"}\n    State of interest:\n    - \"best\": epoch with lowest validation NLL.\n    - \"last\": final epoch.\n    - \"init\": first epoch (index 0).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of (float or None, float or None)\n    A tuple <code>(train_nll, val_nll)</code> for the requested mode.\n    Returns <code>(None, None)</code> if loss files are missing or cannot be read.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This method expects per-node JSON files:</p>\n\n<ul>\n<li><code>train_loss_hist.json</code></li>\n<li><code>val_loss_hist.json</code></li>\n</ul>\n\n<p>in the node directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.get_thetas", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.get_thetas", "kind": "function", "doc": "<p>Return transformed intercept (theta) parameters for a node and state.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : str\n    Node name.\nstate : {\"best\", \"last\", \"init\"}, optional\n    Model state for which to return parameters. Default is \"best\".</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Any or None\n    Transformed theta parameters for the requested node and state.\n    The exact structure (scalar, list, or other) depends on the model.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If an invalid state is given (not in {\"best\", \"last\", \"init\"}).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Intercept dictionaries are cached on the instance under the attribute\n<code>intercept_dicts</code>. If missing or incomplete, they are recomputed using\n<code>get_simple_intercepts_dict</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;best&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.get_linear_shifts", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.get_linear_shifts", "kind": "function", "doc": "<p>Return learned linear shift terms for a node and a given state.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : str\n    Node name.\nstate : {\"best\", \"last\", \"init\"}, optional\n    Model state for which to return linear shift terms. Default is \"best\".</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict or Any or None\n    Linear shift terms for the given node and state. Usually a dict\n    mapping term names to weights.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If an invalid state is given (not in {\"best\", \"last\", \"init\"}).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Linear shift dictionaries are cached on the instance under the attribute\n<code>linear_shift_dicts</code>. If missing or incomplete, they are recomputed using\n<code>get_linear_shifts_dict</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;best&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.get_linear_shifts_dict", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.get_linear_shifts_dict", "kind": "function", "doc": "<p>Compute linear shift term dictionaries for all nodes and states.</p>\n\n<p>For each node and each available state (\"best\", \"last\", \"init\"), this\nmethod loads the corresponding model checkpoint, extracts linear shift\nweights from the TRAM model, and stores them in a nested dictionary.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Nested dictionary of the form:</p>\n\n<pre><code>```python\n</code></pre>\n\n<p>{\n    \"best\": {node: {...}},\n    \"last\": {node: {...}},\n    \"init\": {node: {...}},\n}\n```</p>\n\n<pre><code>where the innermost dict maps term labels (e.g. ``\"ls(parent_name)\"``)\nto their weights.\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>If \"best\" or \"last\" checkpoints are unavailable for a node, only\nthe \"init\" entry is populated.</li>\n<li>Empty outer states (without any nodes) are removed from the result.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.get_simple_intercepts_dict", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.get_simple_intercepts_dict", "kind": "function", "doc": "<p>Compute transformed simple intercept dictionaries for all nodes and states.</p>\n\n<p>For each node and each available state (\"best\", \"last\", \"init\"), this\nmethod loads the corresponding model checkpoint, extracts simple intercept\nweights, transforms them into interpretable theta parameters, and stores\nthem in a nested dictionary.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Nested dictionary of the form:</p>\n\n<pre><code>```python\n</code></pre>\n\n<p>{\n    \"best\": {node: [[theta_1], [theta_2], ...]},\n    \"last\": {node: [[theta_1], [theta_2], ...]},\n    \"init\": {node: [[theta_1], [theta_2], ...]},\n}\n```</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>For ordinal models (<code>self.is_ontram == True</code>), <code>transform_intercepts_ordinal</code>\nis used.</li>\n<li>For continuous models, <code>transform_intercepts_continous</code> is used.</li>\n<li>Empty outer states (without any nodes) are removed from the result.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tramdag.TramDagModel.TramDagModel.summary", "modulename": "tramdag.TramDagModel", "qualname": "TramDagModel.summary", "kind": "function", "doc": "<p>Print a multi-part textual summary of the TramDagModel.</p>\n\n<p>The summary includes:</p>\n\n<ol>\n<li>Training metrics overview per node (best/last NLL, epochs).</li>\n<li>Node-specific details (thetas, linear shifts, optional architecture).</li>\n<li>Basic information about the attached training DataFrame, if present.</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>verbose : bool, optional\n    If True, include extended per-node details such as the model\n    architecture, parameter count, and availability of checkpoints\n    and sampling results. Default is False.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This method prints to stdout and does not return structured data.\nIt is intended for quick, human-readable inspection of the current\ntraining and model state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();